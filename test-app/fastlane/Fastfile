# There are some re-usable functions in other Fastfile files in the org we can re-use. 
import_from_git(
  url: "https://github.com/customerio/customerio-ios.git", 
  branch: "main", 
  path: "Apps/fastlane/Fastfile"
)

platform :android do
  lane :build do |values|
    app_package_name = CredentialsManager::AppfileConfig.try_fetch_value(:package_name)
    firebase_app_id = find_firebase_app_id(app_identifier: app_package_name)

    # Build release APK using Fastlane's Gradle tool
    gradle(
      project_dir: "./android",
      task: "assemble",
      build_type: "Release"
    )

    # Path to the APK generated by gradle (relative to project root)
    distribution_apk_path = "android/app/build/outputs/apk/release/app-release.apk"

    # Adjusted path for checking the APK from the Fastlane directory
    relative_apk_path = "../#{distribution_apk_path}"

    UI.message("Current working directory: #{Dir.pwd}, Looking for APK at: #{relative_apk_path}")
    # Check if the APK exists
    unless File.exist?(relative_apk_path)
      UI.user_error!("Couldn't find the APK at #{relative_apk_path}")
    end

    # function 'setup_google_bucket_access' is a re-usable function inside of apple-code-signing Fastfile that we imported.
    # This allows you to create a temporary file from a GitHub secret for added convenience.
    # When uploading the build to Firebase App Distribution, the CI server needs to authenticate with Firebase. This is done with a
    # Google Cloud Service Account json creds file. The base64 encoded value of this service account file is stored as this secret.
    service_credentials_file_path = setup_google_bucket_access(
      environment_variable_key: "FIREBASE_APP_DISTRIBUTION_SERVICE_ACCOUNT_CREDS_B64"
    )

    firebase_app_distribution(
      apk_path: distribution_apk_path,
      app: firebase_app_id,
      service_credentials_file: service_credentials_file_path,
      groups: get_build_test_groups(distribution_groups: values[:distribution_groups]),
      release_notes: get_build_notes()
    )
  end
end


platform :ios do
  lane :build_ios do |arguments|

    download_ci_code_signing_files_local

    xcodeproj_path = "./ios/ExpoTestbed.xcodeproj"

    update_code_signing_settings(
      use_automatic_signing: false,
      path: xcodeproj_path
    )

    # We use sync_code_signing Fastlane to download certificates https://docs.fastlane.tools/actions/sync_code_signing/
    # This internally uses sigh and it sets environment variables for provisioning profiles paths
    # The format is sign_<bundle-id>_<type>_profile-path
    # This makes sure that if signing files are recreated, they are picked up dynamically without having
    # to update them manually

    update_project_provisioning(
      xcodeproj: xcodeproj_path,
      target_filter: "ExpoTestbed",
      profile: ENV["sigh_io.customer.testbed.expo.apn_adhoc_profile-path"]
    )

    update_project_provisioning(
      xcodeproj: xcodeproj_path,
      target_filter: "NotificationService",
      profile: ENV["sigh_io.customer.testbed.expo.apn.richpush_adhoc_profile-path"]
    )

    update_project_team(
      path: xcodeproj_path,
      teamid: "2YC97BQN3N"
    )

    gym(
      scheme: "ExpoTestbed",
      workspace: "ios/ExpoTestbed.xcworkspace",
      export_method: "ad-hoc",
      configuration: "Release",
      codesigning_identity: "Apple Distribution: Peaberry Software, Inc. (2YC97BQN3N)"
    )

    # function 'setup_google_bucket_access' is a re-usable function inside of apple-code-signing Fastfile that we imported.
    # This allows you to create a temporary file from a GitHub secret for added convenience.
    # When uploading the build to Firebase App Distribution, the CI server needs to authenticate with Firebase. This is done with a
    # Google Cloud Service Account json creds file. The base64 encoded value of this service account file is stored as this secret.
    service_credentials_file_path = setup_google_bucket_access(
      environment_variable_key: "FIREBASE_APP_DISTRIBUTION_SERVICE_ACCOUNT_CREDS_B64"
    )

    firebase_app_distribution(
      service_credentials_file: service_credentials_file_path,
      groups: get_build_test_groups(distribution_groups: arguments[:distribution_groups]),
      release_notes: get_build_notes() + "\nPush provider: #{arguments[:push_provider]}"
    )
  end

  lane :download_ci_code_signing_files_local do |values|  
    google_cloud_keys_file_path = setup_google_bucket_access(
      environment_variable_key: "GOOGLE_CLOUD_MATCH_READONLY_SERVICE_ACCOUNT_B64"
    )
  
    sync_code_signing(
      type: "adhoc",
      readonly: true,
      team_id: "2YC97BQN3N",
      storage_mode: "google_cloud",
      google_cloud_bucket_name: "ios_code_signing_files",
      google_cloud_project_id: "remote-habits",
      google_cloud_keys_file: google_cloud_keys_file_path
    )
  end 
end

lane :update_expo_test_app_version do |values|
  app_json_path = File.join("..", 'app.json')

  unless File.exist?(app_json_path)
    UI.user_error!("app.json not found at #{app_json_path}")
  end

  version_name = values[:sdk_version] || get_new_app_version()
  version_code = get_new_build_version()

  app_json_content = File.read(app_json_path)
  app_json_data = JSON.parse(app_json_content)

  # Update version name and code
  app_json_data['expo']['version'] = version_name if app_json_data['expo']['version']
  app_json_data['expo']['android']['versionCode'] = version_code.to_i
  app_json_data['expo']['ios']['buildNumber'] = version_code.to_s

  UI.message("Updated app.json content #{app_json_data}")

  File.write(app_json_path, JSON.pretty_generate(app_json_data))
  UI.message("Updated version to #{version_name} and versionCode to #{version_code} in #{app_json_path}")
end
