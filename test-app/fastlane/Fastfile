
import_from_git(
  url: "https://github.com/customerio/apple-code-signing.git", 
  branch: "main", 
  path: "fastlane/Fastfile"
)

platform :android do
  lane :build do |values|
    app_package_name = CredentialsManager::AppfileConfig.try_fetch_value(:package_name)
    firebase_app_id = find_firebase_app_id(app_identifier: app_package_name)

    # Build release APK using Fastlane's Gradle tool
    gradle(
      project_dir: "./android",
      task: "assemble",
      build_type: "Release"
    )

    # Path to the APK generated by gradle (relative to project root)
    distribution_apk_path = "android/app/build/outputs/apk/release/app-release.apk"

    # Adjusted path for checking the APK from the Fastlane directory
    relative_apk_path = "../#{distribution_apk_path}"

    UI.message("Current working directory: #{Dir.pwd}, Looking for APK at: #{relative_apk_path}")
    # Check if the APK exists
    unless File.exist?(relative_apk_path)
      UI.user_error!("Couldn't find the APK at #{relative_apk_path}")
    end

    # function 'setup_google_bucket_access' is a re-usable function inside of apple-code-signing Fastfile that we imported.
    # This allows you to create a temporary file from a GitHub secret for added convenience.
    # When uploading the build to Firebase App Distribution, the CI server needs to authenticate with Firebase. This is done with a
    # Google Cloud Service Account json creds file. The base64 encoded value of this service account file is stored as this secret.
    service_credentials_file_path = setup_google_bucket_access(
      environment_variable_key: "FIREBASE_APP_DISTRIBUTION_SERVICE_ACCOUNT_CREDS_B64"
    )

    firebase_app_distribution(
      apk_path: distribution_apk_path,
      app: firebase_app_id, # Firebase app id is required. Get it from google-services.json file
      service_credentials_file: service_credentials_file_path,
      groups: 'feature-branch',
      release_notes: 'Sample release notes'
    )
  end
end

platform :ios do
  lane :build do |arguments|

    download_ci_code_signing_files

    update_project_provisioning(
      xcodeproj: "./ios/ExpoTestApp.xcodeproj",
      target_filter: "ExpoTestApp",
      profile: "/Users/runner/Library/MobileDevice/Provisioning Profiles/ad21ce7c-1f32-40df-a2f4-919c0be79e44.mobileprovision"
    )

    update_project_provisioning(
      xcodeproj: "./ios/ExpoTestApp.xcodeproj",
      target_filter: "NotificationService",
      profile: "/Users/runner/Library/MobileDevice/Provisioning Profiles/c1055dbd-7028-4b54-a22d-807211e19f05.mobileprovision"
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      path: "./ios/ExpoTestApp.xcodeproj"
    )

    gym(
      scheme: "ExpoTestApp",
      workspace: "ios/ExpoTestApp.xcworkspace",
      export_method: "ad-hoc",
      configuration: "Release",
      export_options: {
      provisioningProfiles: {
          "io.customer.ami" => "match AdHoc io.customer.ami",
          "io.customer.ami.richpush" => "match AdHoc io.customer.ami.richpush"
        }
      }
    )

    # function 'setup_google_bucket_access' is a re-usable function inside of apple-code-signing Fastfile that we imported.
    # This allows you to create a temporary file from a GitHub secret for added convenience.
    # When uploading the build to Firebase App Distribution, the CI server needs to authenticate with Firebase. This is done with a
    # Google Cloud Service Account json creds file. The base64 encoded value of this service account file is stored as this secret.
    service_credentials_file_path = setup_google_bucket_access(
      environment_variable_key: "FIREBASE_APP_DISTRIBUTION_SERVICE_ACCOUNT_CREDS_B64"
    )

    firebase_app_distribution(
      service_credentials_file: service_credentials_file_path,
      groups: 'feature-branch',
      release_notes: 'Sample release notes'
    )
  end
end